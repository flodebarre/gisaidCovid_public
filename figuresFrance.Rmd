---
title: "France on GISAID"
author: "FD"
date: 2021-07-21
output: 
  html_document: 
      code_folding: hide
      toc: TRUE
      toc_float: TRUE
      self_contained: no  
---

# Initializations


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, eval = FALSE, include = FALSE}
# This is only for evaluation in the console, not for Rmd
rm(list = ls()) 
options(warn = 2) # Turn warnings into errors to trouble-check
```

```{r}
# Colors 
library(RColorBrewer)
colsV <- rep(c(brewer.pal(12, "Paired"), brewer.pal(12, "Set3"), brewer.pal(9, "Set1")), 20)
colsP <- brewer.pal(5, "Set1")
names(colsP) <- c("autre", "HCL", "HMN", "IHU", "IPP")
colsC <- c(brewer.pal(9, "Set1"), brewer.pal(6, "Set2"), brewer.pal(12, "Set3"))
colsV2 <- brewer.pal(9, "Set3")

colGISAID <- "#106b63"
colECDC <- "#69b023"
colSPF <- "#e30155"

cols <- c(colGISAID, colECDC, colSPF, "#FE6100", "#785EF0")
names(cols) <- c("GISAID", "TESSy", "Flash", "criblage", "option")

pchs <- c(16, 15, 2, 17, 1)
names(pchs) <- c(names(cols)[1:3], "Flash2", "TESSyGISAID")

```

```{r}
# Function to identify entries that are NA or empty
is.NAempty <- function(x){
  is.na(x) | x == ""
}
```

# Load and clean data

Data source: `metadata.tsv`, downloaded from [GISAID](https://www.gisaid.org). 

Then, in console
```
grep "hCoV-19/France" metadata.tsv
```
to extract sequences from France (as country) only. The resulting file is stored in the `data/` folder. 

Note: Oversea territories are referenced as independent on GISAID

Extracted data for Martinique and Guadeloupe as well (`grep Martinique` and `grep Guadeloupe`). 

## Load data

```{r loadData, results = 'hide'}
thedate <- "2021-08-13"
# Load France data
dat <- read.csv(paste0("data/", thedate, "_France.tsv"), sep = "\t", stringsAsFactors = FALSE, header = FALSE)

# Load data DROM
dat2 <- read.csv(paste0("data/", thedate, "_Martinique.tsv"), sep = "\t", stringsAsFactors = FALSE, header = FALSE)
dat3 <- read.csv(paste0("data/", thedate, "_Guadeloupe.tsv"), sep = "\t", stringsAsFactors = FALSE, header = FALSE)

# Add column to distinguish metro from DROM
dat$metropole <- TRUE
dat2$metropole <- FALSE
dat3$metropole <- FALSE

# Join the datasets
dat <- rbind(dat, dat2, dat3)

head(dat)
names(dat) <- c("Virus.name", "Type", "Accession.ID", "Collection.date", "Location", "Additional.location.information", "Sequence.length", "Host", "Patient.age", "Gender", "Clade", "Pango.lineage", "Pangolin.version", "Variant", "AA.Substitutions", "Submission.date", "Is.reference", "Is.complete", "Is.high.coverage", "Is.low.coverage", "N.Content", "GC.Content", "Metropole")
```

There are `r nrow(dat)` lines in the dataset; `r sum(dat$Metropole)` for mainland France, `r nrow(dat2)` for Martinique and `nrow(dat3)` for Guadeloupe. 

## Clean data

Dates: full date, year-month and year

```{r cleanDataDates, echo = TRUE, results = 'hide'}
# Reformat dates

# Table of the lengths of the different dates
table(nchar(dat$Collection.date)) # There are incomplete dates
table(nchar(dat$Submission.date))

# Turn dates into date format, and put NA for incomplete dates
getDate <- function(v){
  out <- v
  # Remove lines with incomplete date information
  out[nchar(out) < 10] <- NA
  base::as.Date(out)
}

dat$Collection.date.YMD <- getDate(dat$Collection.date)
dat$Submission.date.YMD <- getDate(dat$Submission.date)

# Extract month
getYM <- function(v){
  out <- v
  # Remove lines with incomplete date information
  out[nchar(out) < 7] <- NA
  substr(out, 1, 7)
}

dat$Collection.date.YM <- getYM(dat$Collection.date)
dat$Submission.date.YM <- getYM(dat$Submission.date)

# Extract year
getY <- function(v){
  out <- v
  # Remove lines with incomplete date information
  out[nchar(out) < 4] <- NA
  substr(out, 1, 4)
}

dat$Collection.date.Y <- getY(dat$Collection.date)
dat$Submission.date.Y <- getY(dat$Submission.date)
```

Dates: get week numbers  
(currently only done for 2021)

```{r cleanDataWeeks}
# NOTE: THIS IS ONLY FOR 2021 -- need to change method for 2020, or do it separately
endDay <- max(dat$Submission.date.YMD)
beginDay <- seq(base::as.Date("2021-01-04"), base::as.Date("2021-12-27"), by = 7)
endDay <- seq(base::as.Date("2021-01-10"), base::as.Date("2022-01-02"), by = 7)
weeks <- as.data.frame(cbind(weekBegin = beginDay, weekEnd = endDay, week = 1:52))

# Note: weeks numbers can be obtained with 
# > format(as.Date("2021-08-13"), "%W")

# Assign weeks
  # Initialize week numbers
dat$Collection.week <- NA
dat$Submission.week <- NA

for(iw in weeks$week){
  # Collection week
  dat[which(base::as.Date(dat$Collection.date.YMD) >= base::as.Date(weeks[iw, "weekBegin"], origin = "1970-01-01") & base::as.Date(dat$Collection.date.YMD) <= base::as.Date(weeks[iw, "weekEnd"], origin = "1970-01-01")), "Collection.week"] <- iw
  
  # Submission week
  dat[which(base::as.Date(dat$Submission.date.YMD) >= base::as.Date(weeks[iw, "weekBegin"], origin = "1970-01-01") & base::as.Date(dat$Submission.date.YMD) <= base::as.Date(weeks[iw, "weekEnd"], origin = "1970-01-01")), "Submission.week"] <- iw
}
```

Difference between submission and collection dates

```{r}
dat$diffSubCol <- as.numeric(dat$Submission.date.YMD - dat$Collection.date.YMD)
```

Locations:  

Try to get some uniformity automatically because some spellings differ

```{r}
# Split locations
# Locations are presented as a single string, which we split
locs <- strsplit(dat$Location, " / ")
# The strings are of different lengths / precision; get length (number of geographic divisions)
lenlocs <- sapply(locs, length)
table(lenlocs)
# Turn into matrix, filling with NAs
# Source: https://stackoverflow.com/a/15201690
mat <- as.data.frame(t(sapply(locs, "[", i = 1:max(lenlocs))))
names(mat) <- c("continent", "country", "region", "div4", "div5")
dat <- cbind(dat, mat)
# Also add information about location precision
dat <- cbind(dat, locationLength = lenlocs)
names(dat)

# Load dictionnary to convert region names
infoRegion <- read.csv("data_public/correspondance_regions.csv")

# Check that we have all names -- focusing on Metropole
rr <- unique(dat[dat$metropole, "region"])
rr <- rr[!is.na(rr)]
all(is.element(rr, infoRegion$Region_on_GISAID))

# If FALSE, which ones are we missing?
if(!all(is.element(rr, infoRegion$Region_on_GISAID))){
  rr[which(!is.element(rr, infoRegion$Region_on_GISAID))]
}

stopifnot(is.element(rr, infoRegion$Region_on_GISAID))

# Convert into dictionnary
dic.regnames <- c(infoRegion$region)
names(dic.regnames) <- infoRegion$Region_on_GISAID

# Save old region names
dat$oldRegion <- dat$region

# Convert names into the proper region names
dat$region <- dic.regnames[dat$oldRegion]

regions <- sort(unique(dat$region))

# For DROM, information is in Country instead
```


Hosts

```{r cleanDataHosts, echo = TRUE, results = 'hide'}
# Uniformize notation
dat[dat$Host == "human", "Host"] <- "Human"
```

## Flash

Load Flash dates
Available on <https://www.santepubliquefrance.fr/etudes-et-enquetes/enquetes-flash-evaluation-de-la-circulation-des-variants-du-sars-cov-2-en-france>


```{r}
datesFlash <- read.csv("data_public/datesFlash.csv", stringsAsFactors = FALSE)
datesFlash.all <- datesFlash
# Remove Flash 1 and 2, which were not on a random sample
datesFlash <- datesFlash[datesFlash$FlashNb >=3 , ]
```

Flash data 
Typed from <https://www.santepubliquefrance.fr/etudes-et-enquetes/enquetes-flash-evaluation-de-la-circulation-des-variants-du-sars-cov-2-en-france#block-337272>, accessed 2021-07-21

```{r}
dat.Flash <- read.csv("data_public/2021-07-21_Flash.csv")
head(dat.Flash)

dat.Flash$deltaCI <- 1.96 * sqrt(dat.Flash$Proportion * (1 - dat.Flash$Proportion) / dat.Flash$NbPrelevSeq)
```

Specific Flash data

```{r}
# Load Flash 11 data
flash11 <- read.csv("data_public/Flash11_Beta.csv")
flash11 <- flash11[flash11$Region != "Total", ]
flash11$nBeta <- round(flash11$pBeta * flash11$Prelevements)

# Load Flash 10 data
flash10 <- read.csv("data_public/Flash10_Beta.csv")
flash10 <- flash10[flash10$Region != "Total", ]
flash10$nBeta <- round(flash10$pBeta * flash10$Prelevements)

# Load Flash 09 data
flash09 <- read.csv("data_public/Flash09_Beta.csv")
flash09 <- flash09[flash09$Region != "Total", ]
flash09$nBeta <- round(flash09$pBeta * flash09$Prelevements)

# Get codes of Outre-Mer regions
unique(c(flash09$Region, flash10$Region, flash11$Region))
reg_OM <- c("GUA", "REU", "MAR", "MAY")

# Remove Outre-Mer
flash11.noOM <- flash11[which(!is.element(flash11$Region, reg_OM)), ]
flash10.noOM <- flash10[which(!is.element(flash10$Region, reg_OM)), ]
flash09.noOM <- flash09[which(!is.element(flash09$Region, reg_OM)), ]

# Compute total numbers of sequences, and Beta sequences
tot11 <- apply(flash11.noOM[, c("Prelevements", "nBeta")], 2, sum)
tot10 <- apply(flash10.noOM[, c("Prelevements", "nBeta")], 2, sum)
tot09 <- apply(flash09.noOM[, c("Prelevements", "nBeta")], 2, sum)

# Construct final dataset with the results
totFlash.noOM <- data.frame(week = c(19, 21, 23))
totFlash.noOM$nTot <- c(tot09[1], tot10[1], tot11[1])
totFlash.noOM$pBeta <- c(tot09[2]/tot09[1], tot10[2]/tot10[1], tot11[2]/tot11[1])
totFlash.noOM$deltaCI <- 1.96 * sqrt(totFlash.noOM$pBeta * (1-totFlash.noOM$pBeta) / totFlash.noOM$nTot)
totFlash.noOM
```


```{r}
table(country = dat$country)
```

Get submitter information from Virus name

```{r}
ipp <- grep(dat$Virus.name, pattern = "IPP")
hcl <- grep(dat$Virus.name, pattern = "HCL")
ihu <- grep(dat$Virus.name, pattern = "IHU")
hmn <- grep(dat$Virus.name, pattern = "HMN")


dat$submitter <- rep("autre", nrow(dat))
dat[ipp, "submitter"] <- "IPP"
dat[hcl, "submitter"] <- "HCL"
dat[ihu, "submitter"] <- "IHU"
dat[hmn, "submitter"] <- "HMN"

table(dat$submitter, useNA = "ifany")

submitters <- sort(unique(dat$submitter))
```


# Sequence metadata 

Dates

-  The fraction of samples with missing full day of collection is `r round(mean(is.na(dat$Collection.date.YMD)), 2)`  

Distribution of samples with incomplete collection date information, by submitter  
```{r}
totSeq <- table(dat$submitter)
tt <- table(dat[which(is.na(dat$Collection.date.YMD)), "submitter"])

rbind(incomplete_collectionDate = tt, tot_seq = totSeq[names(tt)])
```

Location 

-  The fraction of samples with missing regional information is `r round(mean(is.na(dat$region)), 2)`

Distribution of entries with incomplete location, by submitter  
```{r}
tt <- table(dat[which(is.na(dat$region)), "submitter"])

rbind(missing_region = tt, tot_seq = totSeq[names(tt)])
```

## Metadata on hosts

```{r}
# Hosts
table(dat$Host)
```

Age  
```{r}
# Age
dat[which(is.element(dat$Patient.age, c("unknown", "Unknown"))), "Patient.age"] <- NA

# Convert to numeric values 
# if contains characters -> NA
dat$Patient.age <- suppressWarnings(as.numeric(dat$Patient.age))
```

The fraction of samples with missing or incorrect age information is `r round(mean(is.na(dat$Patient.age)), 2)`.

Missing age by submitter  
```{r}
tt <- table(dat[which(is.na(dat$Patient.age)), "submitter"])
rbind(missing_age = tt, tot_seq = totSeq[names(tt)])
```

Distribution of ages  
```{r}
par(las = 1)
range(dat$Patient.age, na.rm = TRUE)
dat[which(dat$Patient.age >120), "Patient.age"] <- NA
hist(dat$Patient.age, xlab = "Patient age", main = "Distribution of patient ages", breaks = seq(0, max(dat$Patient.age, na.rm = TRUE), by = 1), border = gray(1, 1), col = cols[1])
```

"Gender" information  
```{r, results = 'hide'}
unique(dat$Gender)
# Clean
dat[which(is.element(dat$Gender, c("unknown", "Unknown", "Femal", "Maleale"))), "Gender"] <- NA

table(dat$Gender, useNA = "ifany")
```


```{r}
# Distribution by submitter
rbind(missing_age = table(dat[which(is.na(dat$Gender)), "submitter"]), tot_seq = table(dat$submitter))
```

## Virus


```{r}
# "Clade"                           "Pango.lineage"         
# "Pangolin.version"                "Variant"                 
# "AA.Substitutions"
```

Clades  
```{r}
table(dat$Clade, useNA = "ifany")
```

Pango lineage info is missing in a fraction `r round(mean(is.NAempty(dat$Pango.lineage)), 4)` of items. 

Pangolin version  
```{r}
table(dat$Pangolin.version)
```

# Submissions 

## By Platform

```{r}
tabFRsub <- aggregate(dat$Virus.name, by = list(subID = dat$submitter, subM = dat$Collection.date.YM), FUN = length)

tabFRsub.month <- aggregate(dat$Virus.name, by = list(subM = dat$Collection.date.YM), FUN = length)


par(mgp = c(3, 1, 0))
par(mar = c(5, 5, 3, 1))
x <- barplot(tabFRsub$x ~ tabFRsub$subID + tabFRsub$subM, col = colsP[1:(length(unique(tabFRsub$subID)))], border = gray(0, 0), 
             xlab = "", ylab = "Nb sequences", las = 2, 
             main = "Nombre de séquences par producteur et mois de collecte")

z <- tabFRsub[tabFRsub$subM == "2021-03", ]
text(x = rep(x[length(x)-1], 5), y = cumsum(z$x) - z$x/2, labels = z$subID, adj = c(-0.7, 0.5), col = colsP, cex = 0.9) # pos 4 for left-justified
par(xpd = TRUE)
text(x = x, y = tabFRsub.month$x, labels = tabFRsub.month$x, cex = 0.8, adj = c(0.5, -0.5))
legend("topleft", col = rev(colsP), legend = rev(names(colsP)), pch = 15, bty = "n")
par(xpd = FALSE)
```

By platform, by week
```{r, fig.height=10}
# By collection week
tabFRsub.byweek <- aggregate(dat$Virus.name, by = list(subID = dat$submitter, subweek = dat$Collection.week), FUN = length)
names(tabFRsub.byweek)[3] <- "byCollectionDate"

tabFRsubS.byweek <- aggregate(dat$Virus.name, by = list(subID = dat$submitter, subweek = dat$Submission.week), FUN = length)
names(tabFRsubS.byweek)[3] <- "bySubmissionDate"

seq.byWeek <- merge(tabFRsub.byweek, tabFRsubS.byweek, all = TRUE)
ymax <- 6000

seq.byWeek[is.na(seq.byWeek$byCollectionDate), "byCollectionDate"] <- 0
seq.byWeek[is.na(seq.byWeek$bySubmissionDate), "bySubmissionDate"] <- 0

par(mfrow = c(2, 1))
themar <- c(3, 3.5, 2, 1)
thetck <- -0.01
themgp <- c(2.3, 0.3, 0)
par(mar = themar, mgp = themgp, tck = thetck)

x <- barplot(seq.byWeek$byCollectionDate ~ seq.byWeek$subID + seq.byWeek$subweek, col = colsP[1:(length(unique(tabFRsub$subID)))], border = gray(0, 0), 
             xlab = "", ylab = "Nb sequences", las = 1, 
             main = "Par semaine de prélèvement", xaxs = "i", yaxs = "i", ylim = c(0, ymax))
legend("topleft", col = rev(colsP), legend = rev(names(colsP)), pch = 15, bty = "n")

stopifnot(length(x) == length(unique(seq.byWeek$subweek))) # Make sure that lengths match

xw <- data.frame(cbind(x = x, week = unique(seq.byWeek$subweek)))
ii <- is.element(xw$week, datesFlash.all$week)
par(xpd = TRUE)
text(labels = "*", x = xw[ii, "x"], y = rep(-100, length(xw[ii, "x"])))
par(xpd = FALSE)
mtext("Semaine de prélèvement (* = semaine Flash)", side = 1, line = 1.25)


par(mar = themar, mgp = themgp, tck = thetck)
x2 <- barplot(seq.byWeek$bySubmissionDate ~ seq.byWeek$subID + seq.byWeek$subweek, col = colsP[1:(length(unique(seq.byWeek$subID)))], border = gray(0, 0), 
             xlab = "", ylab = "Nb sequences", las = 1, 
             main = "Par semaine de soumission", xaxs = "i", yaxs = "i", ylim = c(0, ymax))
legend("topleft", col = rev(colsP), legend = rev(names(colsP)), pch = 15, bty = "n")
mtext("Semaine de soumission", side = 1, line = 1.25)

```


### Submitters x Collection dates

```{r}
dat2 <- dat[order(dat$Collection.date.YMD), ]
dat2 <- dat2[dat2$Collection.date.Y == 2021,]

# Add phantom lab with all days
alldates <- seq(as.Date("2021-01-01"), as.Date(max(dat2$Collection.date.YMD, na.rm = TRUE)), by = "day")

phantom <- data.frame(matrix(rep(NA, length(alldates)*ncol(dat)), byrow = TRUE, nrow = length(alldates)))
names(phantom) <- names(dat)
phantom$Collection.date.YMD <- alldates
phantom$submitter <- "Submitter"
dat3 <- rbind(dat2, phantom)
xx <- table(dat3$submitter, as.Date(dat3$Collection.date.YMD))

# diff(as.Date(unique(as.data.frame(xx)$Var2)))
heatmap(table(dat3$submitter, as.Date(dat3$Collection.date.YMD)), Rowv = NA, Colv = NA, scale = "none", col = gray(seq(1, 0, by = -0.01)))
```


### Focus IHU

## IHU 

```{r}
# All sequences
subIHU <- dat[dat$submitter == "IHU", ]

is.short <- (subIHU$Sequence.length < 5000)
missing.day <- (is.na(subIHU$Collection.date.YMD))
missing.month <- (is.na(subIHU$Collection.date.YM))

length(is.short)
length(missing.day)
aggregate(subIHU$Virus.name, by = list(Sanger = is.short, missingDay = missing.day, missingMonth = missing.month), FUN = length)

sum(!is.short)

subIHU.NGS.missingday <- subIHU[!is.short & missing.day, ]

nrow(subIHU.NGS.missingday)

write.csv(subIHU.NGS.missingday[, c("Virus.name", "Accession.ID", "Collection.date", "Submission.date")], file = "data/Export_IHU_NGS-missingCollectionDate.csv")

head(subIHU.NGS.missingday)

table(subIHU.NGS.missingday$Submission.date.YMD)

totSeq <- table(dat$submitter)
tt <- table(dat[which(is.na(dat$Collection.date.YMD)), "submitter"])
rbind(incomplete_collectionDate = tt, tot_seq = totSeq[names(tt)])
tt/totSeq[names(tt)]
```

```{r}
unique(subIHU$Submission.date.YMD)
table(subIHU$Submission.date.YMD)

subIHU.mostrecent <- subIHU[which(subIHU$Submission.date.YMD == max(subIHU$Submission.date.YMD)),]
```


```{r}
dataset <- subIHU[subIHU$Collection.date.YMD > "2021-04-01", ]


table(dataset$Submission.date.YMD)

table(dataset$Collection.date.YMD)

hist(as.Date(subIHU$Submission.date.YMD), breaks = 500)

hist(as.Date(subIHU$Collection.date.YMD), breaks = 200, freq = TRUE, xlab = "Collection date", main = "Collection dates, IHU", col = gray(0.9))
axis(4)


dataset[10,]
unique(subIHU$Variant)

unique(dataset$Location)
nrow(dataset)

sort(table(dataset$Pango.lineage), decreasing = TRUE)

# Rewrite lineage to only plot the most frequent ones
thr <- 0.01 # Threshold for number of sequences: percentage of all sequences
tb <- table(dataset$Pango.lineage) # Number of seqs associated to each lineage
isFreq <- (tb/sum(tb) > thr) # Identify lineages above the abundance threshold
cbind(tb, isFreq) # Check
dataset$newlineage <- dataset$Pango.lineage # Create new column with new lineage
dataset[!is.element(dataset$newlineage, names(tb[isFreq])), "newlineage"] <- "Other" # Write unfrequent lineages as "Other"

byLin <- aggregate(dataset$newlineage, by = list(Lineage = dataset$newlineage, Collection.date = dataset$Collection.date.YMD), FUN = length)
totdate <- aggregate(dataset$newlineage, by = list(Collection.date = dataset$Collection.date.YMD), FUN = length)
names(totdate)[2] <- "tot"

byL <- merge(byLin, totdate, by = "Collection.date")
byL$p <- byL$x / byL$tot

# By month instead of just full collection date
byLinMonth <- aggregate(dataset$newlineage, by = list(Lineage = dataset$newlineage, Collection.date = dataset$Collection.date.YM), FUN = length)
totdate <- aggregate(dataset$newlineage, by = list(Collection.date = dataset$Collection.date.YM), FUN = length)
names(totdate)[2] <- "tot"

byLM <- merge(byLinMonth, totdate, by = "Collection.date")
byLM$p <- byLM$x / byLM$tot



byVar <- aggregate(dataset$VariantShort, by = list(Variant = dataset$VariantShort, Collection.date = dataset$Collection.date.YMD), FUN = length)
totdate <- aggregate(dataset$VariantShort, by = list(Collection.date = dataset$Collection.date.YMD), FUN = length)
names(totdate)[2] <- "tot"

byV <- merge(byVar, totdate, by = "Collection.date")
byV$p <- byV$x / byV$tot

length(unique(byV$Variant))

byL[order(byL$p), ]

# By full collection date
par(mfrow = c(1, 1), las = 2, cex.axis = 0.7, 
    mar = c(4, 4, 2, 1))
bL <- barplot(byL$x ~ byL$Lineage + byL$Collection.date, border = gray(0, 0), 
             xlab = "", ylab = "Nb sequences", 
             legend = TRUE, args.legend = list(x = "topleft", title = "Pango lineage", cex = 1, pt.cex = 2, bty = "n"), col = rep(brewer.pal(9, "Set1"), 10), main = "Lineages by Collection date, IHU")

bLM <- barplot(byLM$x ~ byLM$Lineage + byLM$Collection.date, border = gray(0, 0), 
             xlab = "", ylab = "Nb sequences", 
             legend = TRUE, args.legend = list(x = "topleft", title = "Pango lineage", cex = 1, pt.cex = 2, bty = "n"), col = rep(brewer.pal(9, "Set1"), 10), main = "Lineages by Collection month, IHU")



par(mar = c(4, 4, 1, 4), las = 2)
barplot(byV$x ~ byV$Variant + byV$Collection.date, border = gray(0, 0), 
             xlab = "Collection date", ylab = "Nb sequences", 
             legend = TRUE, args.legend = list(x = "right", cex = 0.9, pt.cex = 0.9, bty = "n"), col = brewer.pal(length(unique(byV$Variant)), "Set3"))




```



# Lineages over time



## Variants

Use short names

```{r}
dat$VariantShort <- dat$Variant

variants <- sort(unique(dat$Variant))
# variants
variantsShort <- c("", "Alpha", "Beta", "Delta", "Gamma", "Eta", "Iota", "Kappa", "Lambda", "Zeta")
# Check
rbind(variants, variantsShort)

# Assign shorter name
for(i in seq_along(variants)){
  dat[which(dat$Variant == variants[i]), "VariantShort"] <- variantsShort[i]
}

```


Load TESSy

```{r}
dlData <- FALSE # Whether to download the data again from the ECDC website
source("TESSy.R")
```


## Beta

```{r}
tessy.Beta <- (dat.tessy.FR$variant == "B.1.351")
tmp <- dat.tessy.FR[tessy.Beta, ]


# Aggregate the data by week of collection
tmp.nBeta <- aggregate(tmp$number_detections_variant, by = list(week = tmp$week), FUN = sum)
# Number of sequences that week
tmp.n <- aggregate(dat.tessy.FR$number_detections_variant, by = list(week = dat.tessy.FR$week), FUN = sum, na.rm = TRUE)
tmp.n2 <- aggregate(dat.tessy.FR$number_sequenced, by = list(week = dat.tessy.FR$week), FUN = unique, na.rm = TRUE)
cbind(tmp.n, tmp.n2)

# Merge and name
tessyBeta.byweek <- merge(tmp.nBeta, tmp.n, by = "week")
names(tessyBeta.byweek) <- c("week", "nBeta", "n")
tessyBeta.byweek$p <- tessyBeta.byweek$nBeta / tessyBeta.byweek$n
# Confidence interval for proportion
tessyBeta.byweek$deltaCI <- with(tessyBeta.byweek, 1.96 * sqrt(p * (1-p)/n))

tessyBeta.byweek
```


```{r, results='hide'}

# Same with GISAID data on TESSy
gisaidTESSy.Beta <- (dat.gisaid.FR$variant == "B.1.351")
gisaidTESSy.byweek <- dat.gisaid.FR[which(gisaidTESSy.Beta), ]

# Are there duplicate values
stopifnot(!any(duplicated(tmp$year_week)))

# Total number of detection
sum(gisaidTESSy.byweek$number_detections_variant)

gisaidTESSy.byweek$p <- gisaidTESSy.byweek$number_detections_variant / gisaidTESSy.byweek$number_sequenced

# Confidence interval for proportion
gisaidTESSy.byweek$deltaCI <- with(gisaidTESSy.byweek, 1.96 * sqrt(p * (1-p)/number_sequenced))

gisaidTESSy.byweek

```


```{r}
par(mfrow = c(1,1))
# is.Beta <- dat$VariantShort == "Beta"

# Version 2 with sublineages
is.Beta <- (substr(dat$Pango.lineage, 1, 7) == "B.1.351")
sum(is.Beta)
mean(is.Beta)

# Aggregate the data by week of collection
tmp.mean <- aggregate(is.Beta, by = list(week = dat$Collection.week), FUN = mean)
# Number of sequences that week
tmp.n <- aggregate(is.Beta, by = list(week = dat$Collection.week), FUN = length)
# Merge and name
Beta.byweek <- merge(tmp.mean, tmp.n, by = "week")
names(Beta.byweek) <- c("week", "p", "n")
# Confidence interval for proportion
Beta.byweek$deltaCI <- with(Beta.byweek, 1.96 * sqrt(p * (1-p)/n))

par(las = 1, mar = c(4, 4, 3, 4), 
    mgp = c(2.5, 0.5, 0), tck = -0.015, 
    xpd = FALSE)
plot(Beta.byweek$week, Beta.byweek$p, 
     xlim = c(19, max(Beta.byweek$week)) + c(-1, 0), 
     xlab = "", ylab = "Proportion Beta", ylim = c(0, 0.225), 
     frame.plot = FALSE, yaxs = "i", main = "Beta", 
     type = "n", 
     axes = FALSE)
axis(4)
axis(1, at =  seq(18, max(Beta.byweek$week), by = 1))
axis(2)
mtext(side = 1, text = "Collection week (* = Flash week)", line = 2)

deltaX <- 0.04 # Offset

for(i in seq(0, 1, by = 0.05)) abline(h = i, col = gray(0.9))

points(Beta.byweek$week, Beta.byweek$p, col = cols["GISAID"], pch = pchs["GISAID"])

arrows(x0 = Beta.byweek$week, y0 = Beta.byweek$p + Beta.byweek$deltaCI, 
       x1 = Beta.byweek$week, y1 = Beta.byweek$p - Beta.byweek$deltaCI, 
       code = 3, angle = 90, length = 0.00, col = cols["GISAID"])

# Add TESSy data
points(as.numeric(tessyBeta.byweek$week) - 2*deltaX, tessyBeta.byweek$p, col = cols["TESSy"], pch = pchs["TESSy"])

arrows(x0 = as.numeric(tessyBeta.byweek$week) - 2*deltaX, y0 = tessyBeta.byweek$p + tessyBeta.byweek$deltaCI, 
       x1 = as.numeric(tessyBeta.byweek$week) - 2*deltaX, y1 = tessyBeta.byweek$p - tessyBeta.byweek$deltaCI, 
       code = 3, angle = 90, length = 0.00, col = cols["TESSy"])

# Add TESSy GISAID data
points(as.numeric(gisaidTESSy.byweek$week) - deltaX, gisaidTESSy.byweek$p, col = cols["GISAID"], pch = pchs["TESSyGISAID"])

arrows(x0 = as.numeric(gisaidTESSy.byweek$week) - deltaX, y0 = gisaidTESSy.byweek$p + gisaidTESSy.byweek$deltaCI, 
       x1 = as.numeric(gisaidTESSy.byweek$week) - deltaX, y1 = gisaidTESSy.byweek$p - gisaidTESSy.byweek$deltaCI, 
       code = 3, angle = 90, length = 0.00, col = cols["GISAID"])


# Add Flash data
dat.Flash.beta <- dat.Flash[dat.Flash$Variant_short == "Beta", ]

points(dat.Flash.beta$week + deltaX, dat.Flash.beta$Proportion, col = adjustcolor(cols["Flash"], 0.8), pch = pchs["Flash"])
arrows(x0 = as.numeric(dat.Flash.beta$week) + deltaX, y0 = dat.Flash.beta$Proportion + dat.Flash.beta$deltaCI, 
       x1 = as.numeric(dat.Flash.beta$week) + deltaX, y1 = dat.Flash.beta$Proportion - dat.Flash.beta$deltaCI, 
       code = 3, angle = 90, length = 0.00, col = cols["Flash"])

# Add Flash data without Outre-Mer
points(totFlash.noOM$week + 2*deltaX, totFlash.noOM$pBeta, col = cols["Flash"], pch = pchs["Flash2"])
arrows(x0 = as.numeric(totFlash.noOM$week) + 2*deltaX, y0 = totFlash.noOM$pBeta + totFlash.noOM$deltaCI, 
       x1 = as.numeric(totFlash.noOM$week) + 2*deltaX, y1 = totFlash.noOM$pBeta - totFlash.noOM$deltaCI, 
       code = 3, angle = 90, length = 0.00, col = cols["Flash"])


par(xpd = TRUE)
text(datesFlash[datesFlash$week >=18, "week"], -0.02, "*")
par(xpd = FALSE)
legend("topleft", col = cols[c("TESSy", "GISAID", "GISAID", "Flash", "Flash")], legend = c("EDCD, source TESSy", "ECDC, source GISAID", "GISAID with country = France", "Flash surveys", "Flash surveys without Overseas France"), pch = pchs[c("TESSy", "TESSyGISAID", "GISAID", "Flash", "Flash2")], bty = "n")

```

There are `r sum(is.Beta)` Beta sequences. 

This is `r mean(is.Beta)` of all sequences.  
This is `r mean(is.Beta[which(dat$Collection.date.YM >= "2021-04")])` of sequences collected since April (included)
This is `r mean(is.Beta[which(dat$Collection.date.YM >= "2021-05")])` of sequences collected since May (included)
This is `r mean(is.Beta[which(dat$Collection.date.YM >= "2021-06")])` of sequences collected since June (included)


```{r}
tessyBeta.byweek

sum(tessyBeta.byweek$nBeta)
sum(tessyBeta.byweek$nBeta)/sum(tessyBeta.byweek$n)

sum(unique(dat.tessy.FR$number_sequenced))
```

### Details on the Beta

```{r}
dat.Beta <- dat[which(is.Beta), ]

table(dat.Beta$submitter)
head(dat.Beta)

tt <- table(dat.Beta[which(is.na(dat.Beta$Collection.date.YMD)), "submitter"])
tt
sum(tt)

tt2 <- table(dat.Beta[which(is.na(dat.Beta$region)), "submitter"])
tt2

# -> dates and regions are OK

agg.Beta.region.month1 <- aggregate(is.Beta, by = list(region = dat$region, month = dat$Collection.date.YM), FUN = sum)
names(agg.Beta.region.month1)[3] <- "nBeta"

agg.Beta.region.month2 <- aggregate(is.Beta, by = list(region = dat$region, month = dat$Collection.date.YM), FUN = length)
names(agg.Beta.region.month2)[3] <- "nSeq"

agg.Beta.region.month <- merge(agg.Beta.region.month1, agg.Beta.region.month2, all = TRUE)

agg.Beta.region.month$pBeta <- agg.Beta.region.month$nBeta / agg.Beta.region.month$nSeq
agg.Beta.region.month$deltaCI <- 1.96 * sqrt((agg.Beta.region.month$pBeta * (1-agg.Beta.region.month$pBeta)) / agg.Beta.region.month$nSeq)
```

```{r}
max(agg.Beta.region.month$nSeq)

max(agg.Beta.region.month$nBeta)

# Remove single sequence
agg.Beta.region.month <- agg.Beta.region.month[agg.Beta.region.month$nBeta != agg.Beta.region.month$nSeq, ]

# Consistency check
sum(agg.Beta.region.month$nBeta)


```



```{r}
fname <- "beta_regions.pdf"
pdf(file = fname, width = 10, height = 12)
layout(matrix(c(0, 7, 14, 
         9, 8, 6, 
         3, 4, 2,
         12, 1, 13, 
         10, 11, 5), byrow = TRUE, ncol = 3))
cexx <- 0.7
ln <- 2
for(reg in regions){

  sub <- agg.Beta.region.month[agg.Beta.region.month$region == reg, ]
  # Source trick https://stackoverflow.com/questions/6242955/converting-year-and-month-yyyy-mm-format-to-a-date
  
  xmin <- min(agg.Beta.region.month[agg.Beta.region.month$nBeta>0, "month"])
  xmax <- max(agg.Beta.region.month[agg.Beta.region.month$nBeta>0, "month"])
  xx <- seq(as.Date(paste(xmin, "-01", sep="")), as.Date(paste(xmax, "-01", sep="")), by = "month")
  
  
  coln <- "#2A7A6A"
  colp <- "#BF9142"#"#f18956"
  
  ymax <- max(agg.Beta.region.month$nBeta)
  xa <- pretty(seq(0, ymax, by = 50))
  ymax <- max(xa)
  
  par(mgp = c(2.75, 0.25, 0), tck = -0.01, 
      mar = c(5, 4, 3, 4), 
      las = 1)
  
  plot(as.Date(paste(sub$month, "-01", sep="")), sub$nBeta, xlim = range(xx), ylim = c(0, max(agg.Beta.region.month$nBeta)), axes = FALSE, 
       xlab = "Collection month", 
       ylab = "", yaxs = "i", 
       type = "n")
  
  for(i in seq(0, ymax, by = 50)){
    abline(h = i, col = gray(0.9))
  }
  
  points(as.Date(paste(sub$month, "-01", sep="")), sub$nBeta, xlim = range(xx), 
       col = coln, pch = 16, 
       type = "h", lwd = 20, lend = "butt")
  
  axis(1, at = xx, labels = format.Date(xx, "%Y %b"), las = 3, cex.axis = 0.6)
  
  axis(2, col = coln, col.axis = coln, at = xa)
  mtext(side = 2, text = "Number of Beta", las = 3, line = ln, col = coln, cex = cexx)
  points(as.Date(paste(sub$month, "-01", sep="")), sub$pBeta * ymax, col = colp, pch = 17, type = "o", lwd = 0.5, cex = 1.5)
  arrows(x0 = as.Date(paste(sub$month, "-01", sep="")), 
         y0 = (sub$pBeta - sub$deltaCI)* ymax, 
         x1 = as.Date(paste(sub$month, "-01", sep="")), 
         y1 = (sub$pBeta + sub$deltaCI)* ymax,
         code = 3, length = 0, lwd = 2, col = colp
  )
  
  axis(4, col = colp, col.axis = colp, at = xa, labels = xa /max(xa))
  mtext(side = 4, text = "Proportion of Beta", las = 3, line = ln, col = colp, cex = cexx)
  
  title(main = reg)

}

plot(0, type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(-1, 1), ylim = c(-1, 1))

legend(x = 0, y = 0, legend = paste0("Source: GISAID, ", thedate, ".\nDistribution across regions and months of the ", toString(sum(agg.Beta.region.month$nBeta)), " seqs \nfor which month and location data are available \n(out of the ", toString(sum(is.Beta)), " Beta sequences).\nBeta: B.1.351*\n\nAttention: Some known data quality issues\n- Collection date is sometimes not the actual collection date \n   but sequencing date;\n- Location is sometimes sequencing lab \n   instead of sampling location."), xjust = 0.5, yjust = 0., bty = "n", cex = 0.78)

dev.off()
system(paste0("open ", fname))
```

IDF in May
```{r}
sub <- dat[which(dat$region == "Île-de-France" & is.Beta), ]

table(sub$submitter, sub$Pango.lineage)

sub2 <- dat[which(dat$region == "Île-de-France" & dat$Collection.date.YM == "2021-05"), ]
table(sub2$submitter)

table(sub$div4, useNA = "ifany")


table(dat$region, dat$submitter)
```

## Delta 

# AA changes

Load screening data (criblage)

```{r}
source("publicData_criblage.R")
```

```{r}
# Extract AA
tmp <- gsub('\\(', '', dat$AA.Substitutions)
tmp <- gsub('\\)', '', tmp)
aa <- strsplit(tmp, ",")
```

## L452R

```{r}
# Extract information on whether the S:L452R is present as aa substitution in the sequence
i.L452R <- sapply(aa, function(x){(is.element("Spike_L452R", x))})
```

Overall, fraction of all sequences with the L452R mutation: `r mean(i.L452R)`.

```{r}
# Aggregate the data by week of collection
# Proportion of sequences with L452R that week
tmp.mean <- aggregate(i.L452R, by = list(week = dat$Collection.week), FUN = mean)
# Number of sequences that week
tmp.n <- aggregate(i.L452R, by = list(week = dat$Collection.week), FUN = length)
# Merge and name
L452R.byweek <- merge(tmp.mean, tmp.n, by = "week")
names(L452R.byweek) <- c("week", "p", "n")
# Confidence interval for proportion
L452R.byweek$deltaCI <- with(L452R.byweek, 1.96 * sqrt(p * (1-p)/n))
```

Which variants harbor the L452R mutation? 

```{r}
tV <- table(dat[which(dat$Collection.week >= 21 & i.L452R), "VariantShort"], useNA = "ifany")
tV/sum(tV)*100

table(dat[which(dat$Collection.week >= 21 & i.L452R), "Pango.lineage"])

```


```{r}
dat.France$deltaCI_C1 <- 1.96 * sqrt(dat.France$tx_C1/100 * (1-dat.France$tx_C1/100) / (dat.France$nb_C1 + dat.France$nb_C0))
```

```{r}

par(las = 1, mar = c(4, 4, 3, 4), 
    mgp = c(2., 0.5, 0), tck = -0.02, 
    xpd = FALSE)
plot(L452R.byweek$week, L452R.byweek$p, xlim = range(dat.France$week, na.rm = TRUE) + c(-1, 0), 
     xlab = "Collection week", ylab = "Proportion L452R", ylim = c(0, 1), 
     frame.plot = FALSE, yaxs = "i", col = cols["GISAID"], pch = 16, main = "L452R")
axis(4)

for(i in seq(0, 1, by = 0.1)) abline(h = i, col = gray(0.9))

arrows(x0 = L452R.byweek$week, y0 = L452R.byweek$p + L452R.byweek$deltaCI, 
       x1 = L452R.byweek$week, y1 = L452R.byweek$p - L452R.byweek$deltaCI, 
       code = 3, angle = 90, length = 0.1, col = cols["GISAID"])

points(dat.France$week, dat.France$tx_C1/100, col = cols["criblage"], pch = 18)

arrows(x0 = dat.France$week, y0 = dat.France$tx_C1/100 + dat.France$deltaCI_C1, 
       x1 = dat.France$week, y1 = dat.France$tx_C1/100 - dat.France$deltaCI_C1, 
       code = 3, angle = 90, length = 0.1, col = cols["criblage"])

legend("topleft", col = cols[c("GISAID", "criblage")], legend = c("in GISAID", "Criblage"), pch = c(16, 18), bty = "n")

par(xpd = TRUE)
text(datesFlash[which(datesFlash$week >= min(dat.France$week, na.rm = TRUE) -1), "week"], -0.125, "*")
```


Que se passe-t-il en semaine 24-25 ? Nombres de sequences par regions

```{r}
tmp25 <- dat[which(i.L452R & dat$Collection.week == 25), ]
table(tmp25$region)

tmp24 <- dat[which(i.L452R & dat$Collection.week == 24), ]
table(tmp24$region)
```

## E484K

```{r}
# Extract information on whether the S:E484K is present as aa substitution in the sequence
i.E484K <- sapply(aa, function(x){(is.element("Spike_E484K", x))})
mean(i.E484K)

# Aggregate the data by week of collection
# Proportion of sequences with L452R that week
tmp.mean <- aggregate(i.E484K, by = list(week = dat$Collection.week), FUN = mean)
# Number of sequences that week
tmp.n <- aggregate(i.E484K, by = list(week = dat$Collection.week), FUN = length)
# Merge and name
E484K.byweek <- merge(tmp.mean, tmp.n, by = "week")
names(E484K.byweek) <- c("week", "p", "n")
# Confidence interval for proportion
E484K.byweek$deltaCI <- with(E484K.byweek, 1.96 * sqrt(p * (1-p)/n))
```


```{r}
table(dat[which(dat$Collection.week >= 21 & i.E484K), "VariantShort"])
```


```{r}
dat.France$deltaCI_A1 <- 1.96 * sqrt(dat.France$tx_A1/100 * (1-dat.France$tx_A1/100) / (dat.France$nb_A1 + dat.France$nb_A0))
```

```{r}
par(las = 1, mar = c(4, 4, 3, 4), 
    mgp = c(2., 0.5, 0), tck = -0.02, 
    xpd = FALSE)
plot(E484K.byweek$week, E484K.byweek$p, xlim = range(dat.France$week, na.rm = TRUE) + c(-1, 0), 
     xlab = "Collection week", ylab = "Proportion E484K", ylim = c(0, 1), 
     frame.plot = FALSE, yaxs = "i", col = cols["GISAID"], pch = 16, main = "E484K")
axis(4)

for(i in seq(0, 1, by = 0.1)) abline(h = i, col = gray(0.9))

arrows(x0 = E484K.byweek$week, y0 = E484K.byweek$p + E484K.byweek$deltaCI, 
       x1 = E484K.byweek$week, y1 = E484K.byweek$p - E484K.byweek$deltaCI, 
       code = 3, angle = 90, length = 0.1, col = cols["GISAID"])

points(dat.France$week, dat.France$tx_A1/100, col = cols["criblage"], pch = 18)

arrows(x0 = dat.France$week, y0 = dat.France$tx_A1/100 + dat.France$deltaCI_A1, 
       x1 = dat.France$week, y1 = dat.France$tx_A1/100 - dat.France$deltaCI_A1, 
       code = 3, angle = 90, length = 0.1, col = cols["criblage"])

legend("topleft", col = cols[c("GISAID", "criblage")], legend = c("in GISAID with country = France", "Criblage"), pch = c(16, 18), bty = "n")

par(xpd = TRUE)
text(datesFlash[which(datesFlash$week >= min(dat.France$week, na.rm = TRUE) -1), "week"], -0.125, "*")
```

```{r}
par(las = 1)
plot(dat.France$week, dat.France$nb_pos/7 * dat.France$tx_A1/100, col = cols["criblage"], pch = 18, 
     yaxs = "i", 
     frame.plot = FALSE, ylim = c(0, 1.05*max(dat.France$nb_pos/7 * dat.France$tx_A1/100)), 
     xlab = "week", ylab = "nb of cases with E484K", main = "E484K mutation")

arrows(x0 = dat.France$week, y0 = dat.France$nb_pos/7 * (dat.France$tx_A1/100 + dat.France$deltaCI_A1), 
       x1 = dat.France$week, y1 = dat.France$nb_pos/7 * (dat.France$tx_A1/100 - dat.France$deltaCI_A1), 
       code = 3, angle = 90, length = 0.1, col = cols["criblage"])

```

```{r}

for(cw in 22:28){
  tmp <- dat[which(dat$Collection.week == cw & i.E484K), ]
  print(cw)
  tb <- table(tmp$VariantShort)
  print(tb)
  print(c(sum(tb), tb["Beta"], tb["Beta"]/sum(tb)))
}
table(dat[which(dat$Collection.week >= 21 & i.E484K), "VariantShort"])

```

# DROM

```{r}
datM <- dat[dat$country == "Martinique", ]
datG <- dat[dat$country == "Guadeloupe", ]

datM


for(col in c("Pango.lineage", "VariantShort")){
for(ctr in c("Martinique", "Guadeloupe")){
dataset <- dat[dat$country == ctr, ]

# Extract AA
tmp <- gsub('\\(', '', dataset$AA.Substitutions)
tmp <- gsub('\\)', '', tmp)
aaa <- strsplit(tmp, ",")

# Extract information on whether the S:L452R is present as aa substitution in the sequence
ii.L452R <- sapply(aaa, function(x){(is.element("Spike_L452R", x))})

cat(ctr, "\n")
print(table(dataset[which(ii.L452R), "Pango.lineage"]))

byLin <- aggregate(dataset[, col], by = list(Lineage = dataset[, col], Collection.date = dataset$Collection.date.YMD), FUN = length)
totdate <- aggregate(dataset[, col], by = list(Collection.date = dataset$Collection.date.YMD), FUN = length)
names(totdate)[2] <- "tot"
byL <- merge(byLin, totdate, by = "Collection.date")
byL$p <- byL$x / byL$tot
byL[order(byL$p), ]

# By full collection date
par(mfrow = c(1, 1), las = 2, cex.axis = 0.7, 
    mar = c(4, 4, 2, 1))
bL <- barplot(byL$x ~ byL$Lineage + byL$Collection.date, border = gray(0, 0), 
             xlab = "", ylab = "Nb sequences", 
             legend = TRUE, args.legend = list(x = "topleft", title = col, cex = 1, pt.cex = 2, bty = "n"), col = rep(brewer.pal(9, "Set1"), 10), main = paste0(col, " by Collection date, ", ctr))
par(xpd = FALSE)
for(i in 1:100){
  abline(h = i, col = gray(1))
}
}
}
```

 